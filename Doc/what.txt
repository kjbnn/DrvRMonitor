Адресация элемента определяется не позицией в дереве, 
а типом элемента:
		 _______ _______ _______ _______
		|       |       |       |       |
		| Type	|  Net	|  Big  | Small |
		|_______|_______|_______|_______|
		|       |       |       |       |
Драйвер		|   +   |   +   |   +   |       |
Рубеж-монитор	|   +   |   +   |       |       |
БЦП		|   +   |   +   |   +   |       |
Zn/СУ/ТС/Gr/UD	|   +   |   +   |   +   |   +   |
TZ/User/Script	|   +   |   +   |   +   |   +   |
		|_______|_______|_______|_______|

Режимы работы:
1. сравнения/синхронизации баз Ростэк и Рубеж-Монитор
2. рабочий - протоколирование сообщений Рубеж-Монитор, категоризация (событие, изменение элемента)
2а. при событии "изменение какого-либо элемента" базы синхронизируются и протоколируется событие
	
Синхронизация баз:
1. Если начальная синхронизация, то проходим по всем элементам 
	и запоминаем их type + net + big + small во внутреннием списке.
	Списки организуются для каждой таблицы в базах T, P.
2. Анализ типа элемента
3. Формирование запроса UPDATE OR INSERT INTO элемента на основе Id родительского элемента конкретной таблицы.
	В участии принимаются таблицы:	element, sensor, controller, object, ...

'select code_id, category_id, code_name, code_kind, code_value, alarm_level from CATEGORY_CODE'
'select c.drive_id,c.category_id,c.drive_name, d.COMMAND_PARAM from CATEGORY_DRIVE c, CATEGORY_DRIVE_COMMAND d where c.drive_id=d.drive_id'
'select CATEGORY_ID, CHILD_COUNT, PARENT_ID, CATEGORY_NAME, SYSTEM_DEVICE, TYPE_DEVICE from ELEMENT_CATEGORY'
'select STATE_ID, STATE_NAME, PROPERTY_ID, CATEGORY_ID, PROPERTY_VALUE from PROP$STATE '
'select ELEMENT_ID, PARENT_ID, CATEGORY_ID, TYPE_ID, PLACE_ID, CHILD_COUNT, element_name, SYSTEM_DEVICE, TYPE_DEVICE, NET_DEVICE, BIG_DEVICE, SMALL_DEVICE, USER_GROUP_EVENT, user_group_drive, DOMAIN_ID from ELEMENT'
'select E.ELEMENT_ID, E.PARENT_ID, T.ELEMENT_TYPE_NAME, E.ELEMENT_NAME from ELEMENT E, ELEMENT_TYPE T where T.element_type_id=E.element_type_id '
'select O.OBJECT_ID, O.CLASS_ID, O.ELEMENT_ID, P1.PROPERTY_VALUE as LAST_NAME, P2.PROPERTY_VALUE as FIRST_NAME, P3.PROPERTY_VALUE as MID_NAME, P4.PROPERTY_VALUE as status, P5.PROPERTY_VALUE as bday,';
        HumanSQL.SQL.Add('P.pass_id, P.current_card_id, P.demand_id, PC.PASS_CATEGORY_NAME, PS.PASS_STATUS_NAME,');
        HumanSQL.SQL.Add('O.last_update_moment as obj_update, P.last_update_moment as pass_update, (case when (O.object_foto IS NULL) then 0 else 1 end) as IsFotoExist');
        HumanSQL.SQL.Add('from OBJECT O, object_property P1, object_property P2, object_property P3, object_property P4, object_property P5, PASS P, PASS_CATEGORY PC, PASS_STATUS PS');
        HumanSQL.SQL.Add('where (P1.object_id=O.object_id and P1.class_property_id=1) and (P2.object_id=O.OBJECT_ID and P2.class_property_id=2) and (P3.object_id=O.OBJECT_ID and P3.class_property_id=3)');
        HumanSQL.SQL.Add('and (P4.object_id=O.object_id and P4.class_property_id=5) and (P.object_id=O.object_id) and (PC.PASS_CATEGORY_ID=P.PASS_CATEGORY_ID) and (PS.PASS_STATUS_ID=P.PASS_STATUS_ID)');
        HumanSQL.SQL.Add('and (P5.object_id=O.object_id and P5.class_property_id=4)');
'select c.card_id, c.pin_code, c.pass_id, c.access_level_id, c.is_virtual, k.card_category_name, s.card_state_name';
        CardSQL.SQL.Add('from card c, card_category k, card_state s');
        CardSQL.SQL.Add('where (c.card_category_id=k.card_category_id) and (c.card_state_id=s.card_state_id)');
FotoSQL.SQL.Text:='select O.OBJECT_FOTO from OBJECT O where O.object_id='+IntToStr(obj)
	FotoSQL.SQL.Text:='select O.OBJECT_FOTO from OBJECT O, PASS P where O.object_id=P.object_id and P.pass_id='+IntToStr(pass)
	FotoSQL.SQL.Text:='select O.OBJECT_FOTO from OBJECT O, PASS P where O.object_id=P.object_id and P.current_card_id='+IntToStr(card);
'select EMPLOYEE_ID, USER_ID from EMPLOYEE_GROUP where GROUP_ID='+IntToStr(grp);

'select OPERATOR_ID, OPERATOR_NAME, DOMAIN_ID from OPERATOR where OPERATOR_ID>0'  - Получили запрос узлов ОТС
 
PAP_SQL.SQL.Text:='select p.pass_id, p.start_date_time, p.stop_date_time, p.access_level_id, ll.flevel, ll.fbranch, lr.freader,lr.fnetdevice, lr.fbigdevice, lr.fsmalldevice';
	PAP_SQL.SQL.Add('from pass p, cfg$llevel ll, cfg$levrdr lr');
	PAP_SQL.SQL.Add('where p.pass_id='+IntToStr(p_id)+' and ll.flogiclevel=p.access_level_id and ll.flevel>0 and (lr.flevel=ll.flevel and lr.fbranch=ll.fbranch and lr.ftimezone>1)');
 



Протоколирование:
1. Идентификация категории события куда протоколировать (в T или в T/P)
2. 









Руководство по эксплуатации

Назначение
Драйвер Рубеж-Монитор (далее драйвер) предназначен для трансляции сообщений из ПО Рубеж-Монитор (Сигма-ИС г. Москва) в ПО РОСТЭК. 
Принятые сообщения можно ретраняслировать во внешние системы, поодерживаемые в ПО РОСТЭК, например, в R-Platforma (Рубеж г. Саратов).
Драйвер работает в среде ОС Windows и на компьютере с характеристиками аналогичными или выше, необходимых для работы ПО Рубеж-Монитор.

Требование
Работа драйвера осуществляется в настроенной среде Ростек и установленной СУБД Firebird 3.

Установка 
Установка заключается в копировании файла драйвера в отдельную директорию.
Запустите выполнение файла reg.reg, предварительно прописав в нем параметр "path"с указанием директории установки драйвер.
Запустите исполняемый файл драйвера. В директорию драйвера появятся файлы setting.ini и DrvRMonitor.ini содеращие настройки работы драйвера, которые можно изменить.

Содержание файла setting.ini 
....

Содержание файла DrvRMonitor.ini
....

Работа
Драйвер работет в среде ПО РОСТЭК и использует его базы и транспортный уоровень.
Состояние работы драйвера и транслируемые сообщения сохраняются в файле лога драйвера DrvRMonitor.log.
После редактирования конфигурации ПО Рубеж-Монитор в Рубеж Конфигураторе в конфигурации следует выделить узел "Зоны" и вызвать мышью локальное меню "Вывести на печать информацию по зонам с ТС"
После этого драйвер будет принимать от ПО Рубеж-Монитор сообщения на основе обновленной конфигурации.






